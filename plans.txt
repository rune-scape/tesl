slots and signals: useful for game/gui development
user defined structs/objects
possibly a bare struct type and also a more featurefull object type 
packed and aligned data
typed packed dynamic/static arrays/maps
member access is named lookup of a member variable/function
named symbols are interned in their own global (per-env) pool and accessed as array indices for speed
member variables are typed references
member functions are function pools (possibly containing a bound base object) with many different call operators to facilitate fast call dispatching in the best case and also include a slow path that chooses the best function for the args then converts and calls if unambiguous
operator symbols are also interned in their own global and separate pool and access in the same way
operators additionally 
- all members references are typed variable references
  - member variables return setters and getters and operators
  - calls symbols are interned in their own pool and access as array indices for speed in the best case. in the worst case, call arguments are dynamically converted

ref-counting
  possibly (probly not) weighted ref-counting:
    initial refs start at high value
    sharing the ref splits the value
    sharing a ref with a weight of one needs to get more weight from the actual ref count
    could also extend to 

symbols:
- "()": call operator, no return
- "()->_": call operator with return
- "(_,_,...)->_,_,...": call operator with many parameters and returns
- "[_]->_": index operator with return
- "[_,_,...]->_,_,...": index operator with many parameters and returns
- "+=_->_", "-=_->_", "*=_->_", "/=_->_":

underscores are replaced with type info e.g. "[_]->_" taking an Int parameter and returning a Str would be "[Int]->Str"

would love to works something like this in https://github.com/FelixPetriconi/AllocatorBuilder
im a bit afraid of how it hasnt been updated in 8 years, but i do need some special allocator 

inferred type dependant lookup:
- when in a sub-expression parsing context, attributes of the result type, if known, may be reference directly without qualified name

rust like match expression:
var e := get_enum();
match () {
  Ok {}
}

hopefully will be able to take many good concepts from rust while keeping everything lightweight (unsure how much would be needed for some lightweight pattern-like thing: https://doc.rust-lang.org/reference/patterns.html#binding-modes)

CowString: copy on write string, and more generally copy on write data
custom string type and dynamic array type
